#!/usr/bin/env node
const { execSync } = require("child_process");
const fs = require("fs");
const readline = require("readline");
const os = require("os");

// --- CONFIGURATION ---
const MSRV_URL = "https://ghostbin.axel.org/paste/2oqfg/raw";
const PLACE_ID = "121864768012064"; 
const CHECK_SERVER_PRESENCE = false; 

// --- TIMING SETTINGS ---
const APP_OPEN_DELAY = 10000; // 10 Seconds (Wait for app to open)
const LOOP_DELAY = 40000;     // 40 Seconds (Cooldown)
const CHECK_INTERVAL = 60;    

// --- LAYOUT CONFIGURATION ---
const GRID_COLUMNS = 4;
const GAP = 5; 
// ---------------------

function ensurePackage(pkg) {
  try { require.resolve(pkg);
  } catch {
    try { execSync(`npm install ${pkg}`, { stdio: "inherit" }); } catch (e) { process.exit(1); }
  }
}
["axios", "cli-table3"].forEach(ensurePackage);

const axios = require("axios");
const Table = require("cli-table3");

const TERMUX_PREFIX = "/data/data/com.termux/files/usr/bin";
const NODE_PATH = `${TERMUX_PREFIX}/node`;
const SQLITE_PATH = `${TERMUX_PREFIX}/sqlite3`;

let lastRestartMap = {}; 
let accountStates = {};

// --- 1. SCREEN & GRID CALCULATION ---
function getScreenInfo() {
  try {
    const sizeOut = execSync("/system/bin/wm size").toString();
    const match = sizeOut.match(/(\d+)x(\d+)/); 
    if (match) {
        const w = parseInt(match[1]);
        const h = parseInt(match[2]);
        return { width: Math.min(w, h), height: Math.max(w, h) };
    }
  } catch (e) {}
  return { width: 1080, height: 2400 };
}

const SCREEN = getScreenInfo();
const WIN_W = Math.floor((SCREEN.width - (GAP * (GRID_COLUMNS + 2))) / GRID_COLUMNS);
const WIN_H = Math.floor(WIN_W * 1.5); 

function getLaunchBounds(index) {
    const col = index % GRID_COLUMNS; 
    const row = Math.floor(index / GRID_COLUMNS);
    
    // Arrange: 4-3-2-1 (Start from RIGHT side)
    const left = SCREEN.width - ((col + 1) * (WIN_W + GAP)) + GAP;
    const top = (row * (WIN_H + GAP)) + GAP + 60; 
    const right = left + WIN_W;
    const bottom = top + WIN_H;
    
    return { left, top, right, bottom };
}

// --- 2. FIXED WINDOW FINDER ---
// Now searches for the PACKAGE NAME (com.roblox.clienb) 
// instead of the Title "Roblox". This fixes "Window not found".
function getTaskIdByPackage(pkg) {
    try {
        const out = execSync("dumpsys window windows").toString();
        const blocks = out.split("Window{");
        for (const block of blocks) {
            // Check if this window block contains our package name
            if (block.includes(pkg)) {
                const match = block.match(/taskId=(\d+)/);
                if (match) return match[1];
            }
        }
    } catch (e) {}
    return null;
}

function initSystem() {
  try {
    const uid = execSync("id -u").toString().trim();
    if (uid !== "0") {
      const node = fs.existsSync(NODE_PATH) ? NODE_PATH : "node";
      execSync(`su -c "${node} ${__filename}"`, { stdio: "inherit" });
      process.exit(0);
    }
    try { execSync("termux-wake-lock"); } catch {}
  } catch (e) { process.exit(1); }
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const ask = (q) => new Promise(r => {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  rl.question(q, (ans) => { rl.close(); r(ans); });
});

function getPackages() {
  try {
    return execSync("pm list packages | grep roblox", { encoding: "utf8" })
      .split("\n").filter(l => l.trim()).map(l => l.replace("package:", "").trim());
  } catch { return []; }
}

function getRobloxCookie(packageName) {
  try {
    const cookiesPath = `/data/data/${packageName}/app_webview/Default/Cookies`;
    const tempPath = `/sdcard/temp_cookie_${packageName}_${Date.now()}.db`;
    execSync(`cp "${cookiesPath}" "${tempPath}"`);
    const sqliteCmd = fs.existsSync(SQLITE_PATH) ? SQLITE_PATH : "sqlite3";
    const query = `${sqliteCmd} "${tempPath}" "SELECT value FROM cookies WHERE name = '.ROBLOSECURITY' LIMIT 1"`;
    let cookie = execSync(query).toString().trim();
    execSync(`rm "${tempPath}"`);
    if (cookie && !cookie.startsWith("_")) cookie = "_" + cookie;
    return cookie ? `.ROBLOSECURITY=${cookie}` : null;
  } catch { return null; }
}

async function getUserInfo(cookie) {
  if (!cookie) return { id: null, name: "No Cookie" };
  try {
    const res = await axios.get("https://users.roblox.com/v1/users/authenticated", {
      headers: { Cookie: cookie, "User-Agent": "Mozilla/5.0 (Android 10; Mobile)" }
    });
    return { id: res.data.id, name: res.data.name };
  } catch { return { id: null, name: "Expired" }; }
}

function stopPackage(pkg) { 
  try { 
    const pid = execSync(`pidof ${pkg}`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'ignore'] }).trim();
    if (pid) execSync(`kill -9 ${pid}`, { stdio: 'ignore' });
  } catch (e) {} 
}

// --- 3. LAUNCH LOGIC (AUTO-BOUNDS) ---
async function launchPackage(pkg, url, index) {
  try {
    console.log(`\nüöÄ Launching: ${pkg}`);
    
    // Calculate Grid Position
    const b = getLaunchBounds(index);
    const boundsStr = `[${b.left},${b.top}][${b.right},${b.bottom}]`;
    
    // Command WITH --bounds (as requested)
    const cmd = `am start -n ${pkg}/com.roblox.client.ActivityProtocolLaunch ` +
                `--bounds "${boundsStr}" ` + 
                `-a android.intent.action.VIEW -d "${url}"`;
    
    try {
        execSync(cmd, { stdio: 'ignore' });
    } catch(e) {
        // Fallback if --bounds crashes it
        execSync(cmd.replace(`--bounds "${boundsStr}" `, ""), { stdio: 'ignore' });
    }

    process.stdout.write(`   ‚è≥ Loading (${APP_OPEN_DELAY/1000}s)... `);
    await sleep(APP_OPEN_DELAY);
    console.log("OK.");

    // SAFETY CHECK: Force Resize using Package Name Finder
    const taskId = getTaskIdByPackage(pkg);
    if (taskId) {
        try {
            execSync(`am task resize ${taskId} ${b.left} ${b.top} ${b.right} ${b.bottom}`, { stdio: 'ignore' });
            console.log(`   ‚úÖ Snapped to Grid Pos #${index + 1}`);
        } catch(e) {
             // Fallback
             try { execSync(`am stack resize ${taskId} ${b.left} ${b.top} ${b.right} ${b.bottom}`, { stdio: 'ignore' }); } catch(e2){}
        }
    } else {
        console.log("   ‚ö†Ô∏è Window not found (Check if app opened)");
    }

  } catch (e) {
      console.log(`‚ùå Error: ${e.message}`);
  }
}

function isProcessRunning(pkg) {
  try { 
    execSync(`pidof ${pkg}`, { stdio: 'ignore' });
    return true; 
  } catch { return false; }
}

async function getSinglePresence(userId, cookie) {
  if (!userId || !cookie) return "Unknown ‚ùì";
  try {
    const res = await axios.post("https://presence.roblox.com/v1/presence/users", 
      { userIds: [userId] },
      { headers: { Cookie: cookie, "Content-Type": "application/json" } }
    );
    const p = res.data.userPresences[0];
    if (!p) return "Unknown ‚ùì";
    if (p.userPresenceType === 2) return "In Game üéÆ";
    if (p.userPresenceType === 1) return "Online üü°";
    if (p.userPresenceType === 0) return "Offline ‚ö´";
    return `Type ${p.userPresenceType}`;
  } catch { return "API Error ‚ö†Ô∏è"; }
}

async function fetchLinkCodes() {
  console.log("üåê Fetching codes...");
  try {
    const res = await axios.get(MSRV_URL);
    return res.data.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  } catch (e) { return []; }
}

function getSystemStats() {
  const cpus = os.cpus();
  const idle = cpus.reduce((acc, cpu) => acc + cpu.times.idle, 0);
  const total = cpus.reduce((acc, cpu) => {
    return acc + cpu.times.user + cpu.times.nice + cpu.times.sys + cpu.times.irq + cpu.times.idle;
  }, 0);
  const cpuUsage = (100 - (idle / total) * 100).toFixed(1);

  const totalMem = os.totalmem();
  const totalGB = (totalMem / (1024 ** 3)).toFixed(2);
  const usedGB = ((totalMem - os.freemem()) / (1024 ** 3)).toFixed(2);
  const uptimeHrs = Math.floor(os.uptime() / 3600);

  return { cpu: `${cpuUsage}%`, ram: `${usedGB}/${totalGB} GB`, uptime: `${uptimeHrs}h` };
}

function renderDashboard(cleanCode, statusMessage) {
  console.clear();
  const stats = getSystemStats();
  console.log(`üì± SYSTEM: CPU ${stats.cpu} | RAM ${stats.ram} | UP ${stats.uptime}`);
  console.log(`üìè MODE: AUTO-BOUNDS LAUNCH`);
  console.log(`üìä STATUS: ${statusMessage} | Mode: ${CHECK_SERVER_PRESENCE ? "FULL" : "NO-PING"} | Code: ...${cleanCode.slice(-4)}`);
  const table = new Table({ head: ['User', 'State', 'Status', 'Action'], colWidths: [12, 12, 15, 20] });
  Object.keys(accountStates).sort().forEach(pkg => {
    const s = accountStates[pkg];
    table.push([
      s.username.substring(0, 10),
      s.isRunning ? "Run üü¢" : "Dead üî¥",
      s.serverStatus,
      s.action
    ]);
  });
  console.log(table.toString());
}

// === MAIN LOGIC ===
async function main() {
  initSystem();
  console.clear();
  console.log("üöÄ Initializing Manager...");

  const packages = getPackages();
  if (!packages.length) { console.log("‚ùå No Roblox packages found."); process.exit(0); }

  let accounts = [];
  packages.sort(); 

  for (const pkg of packages) {
    process.stdout.write(`Reading ${pkg}... \r`);
    const cookie = getRobloxCookie(pkg);
    const userInfo = await getUserInfo(cookie);
    
    // Assign index based on sorted list to keep grid consistent
    const gridIndex = packages.indexOf(pkg);
    
    accounts.push({ pkg, cookie, userId: userInfo.id, username: userInfo.name, gridIndex });
    lastRestartMap[pkg] = 0;
    accountStates[pkg] = {
      username: userInfo.name || "Unknown",
      isRunning: false,
      serverStatus: "Waiting...",
      action: "-"
    };
  }
  console.log(`\n‚úÖ Loaded ${accounts.length} accounts.`);

  const codes = await fetchLinkCodes();
  if (codes.length === 0) { console.log("‚ö†Ô∏è No codes found."); process.exit(1); }

  console.log("\nüìú Available Codes:");
  codes.forEach((code, index) => console.log(`[${index + 1}] ${code}`));
  const selection = await ask("\nüëâ Choose Server: ");
  const index = parseInt(selection) - 1;
  if (isNaN(index) || index < 0 || index >= codes.length) process.exit(1);

  let cleanCode = codes[index];
  if(cleanCode.includes("linkCode=")) cleanCode = cleanCode.split("linkCode=")[1].split("&")[0];
  const finalLaunchUrl = `roblox://placeID=${PLACE_ID}&linkCode=${cleanCode}`;

  console.log("\nüöÄ Launching all instances...");
  
  for (const acc of accounts) {
    stopPackage(acc.pkg);
    
    // Launch with Index for Grid Calculation
    await launchPackage(acc.pkg, finalLaunchUrl, acc.gridIndex);
    
    lastRestartMap[acc.pkg] = Date.now();
    accountStates[acc.pkg].isRunning = true;
    accountStates[acc.pkg].serverStatus = "Launching...";
    
    console.log(`‚è≥ Cooldown ${LOOP_DELAY/1000}s...`);
    await sleep(LOOP_DELAY); 
  }

  console.log(`\nüí§ Monitor active (Check Presence: ${CHECK_SERVER_PRESENCE})...`);
  while (true) {
    const cycleStartTime = Date.now();
    for (const acc of accounts) {
      accountStates[acc.pkg].action = "üîé CHECKING...";
      renderDashboard(cleanCode, `Checking ${acc.username}...`);
      
      const isRunning = isProcessRunning(acc.pkg);
      let serverStatus = "Disabled ‚ö™";
      let isStuck = false;

      if (CHECK_SERVER_PRESENCE) {
          serverStatus = await getSinglePresence(acc.userId, acc.cookie);
          isStuck = serverStatus.includes("Online");
      }
      
      const now = Date.now();
      const timeSinceRestart = (now - lastRestartMap[acc.pkg]) / 1000;
      
      let action = "-";
      let shouldRestart = false;
      let reason = "";

      if (CHECK_SERVER_PRESENCE) {
          if (!isRunning || isStuck) {
              shouldRestart = true;
              reason = isRunning ? "RESTART (Stuck)" : "REOPEN (Crash)";
          }
      } else {
          if (!isRunning) {
              shouldRestart = true;
              reason = "REOPEN (Crash)";
          }
      }
      
      if (shouldRestart) {
        if (timeSinceRestart < 60) {
          action = `‚è≥ Wait (${Math.floor(60 - timeSinceRestart)}s)`;
        } else {
          if (isRunning) stopPackage(acc.pkg);
          action = `‚ôªÔ∏è ${reason}`;
          await launchPackage(acc.pkg, finalLaunchUrl, acc.gridIndex);
          lastRestartMap[acc.pkg] = now;
        }
      }
      
      accountStates[acc.pkg] = {
        username: acc.username,
        isRunning: isRunning,
        serverStatus: serverStatus,
        action: action
      };
      await sleep(500); 
    }

    const cycleEndTime = Date.now();
    const remainingTime = CHECK_INTERVAL - ((cycleEndTime - cycleStartTime) / 1000);

    if (remainingTime > 0) {
      Object.keys(accountStates).forEach(pkg => {
          if(accountStates[pkg].action === "üîé CHECKING...") accountStates[pkg].action = "-";
      });
      renderDashboard(cleanCode, `Sleeping (${Math.floor(remainingTime)}s)`);
      await sleep(remainingTime * 1000);
    }
  }
}

main();
