#!/usr/bin/env node
const { execSync } = require("child_process");
const fs = require("fs");
const readline = require("readline");

// --- CONFIGURATION ---
const MSRV_URL = "https://raw.githubusercontent.com/abinoldi/muffinz/refs/heads/main/msrv";
const PLACE_ID = "121864768012064"; // Fixed Place ID for the game
const MIN_DELAY_SECONDS = 60; // Anti-lag delay
// ---------------------

// Auto-install dependencies
function ensurePackage(pkg) {
  try { require.resolve(pkg); } catch {
    console.log(`üì¶ Installing ${pkg}...`);
    try { execSync(`npm install ${pkg}`, { stdio: "inherit" }); } catch (e) { process.exit(1); }
  }
}
["axios", "cli-table3"].forEach(ensurePackage);

const axios = require("axios");
const Table = require("cli-table3");

// Termux Paths
const TERMUX_PREFIX = "/data/data/com.termux/files/usr/bin";
const NODE_PATH = `${TERMUX_PREFIX}/node`;
const SQLITE_PATH = `${TERMUX_PREFIX}/sqlite3`;

// Root & Wake Lock
function initSystem() {
  try {
    const uid = execSync("id -u").toString().trim();
    if (uid !== "0") {
      console.log("‚ö†Ô∏è  Root required. Switching...");
      const node = fs.existsSync(NODE_PATH) ? NODE_PATH : "node";
      execSync(`su -c "${node} ${__filename}"`, { stdio: "inherit" });
      process.exit(0);
    }
    try { execSync("termux-wake-lock"); } catch {}
  } catch (e) { process.exit(1); }
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const ask = (q) => new Promise(r => {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  rl.question(q, (ans) => { rl.close(); r(ans); });
});

// Helpers
function getPackages() {
  try {
    return execSync("pm list packages | grep roblox", { encoding: "utf8" })
      .split("\n").filter(l => l.trim()).map(l => l.replace("package:", "").trim());
  } catch { return []; }
}

function getRobloxCookie(packageName) {
  try {
    const cookiesPath = `/data/data/${packageName}/app_webview/Default/Cookies`;
    const tempPath = `/sdcard/temp_cookie_${packageName}_${Date.now()}.db`;
    execSync(`cp "${cookiesPath}" "${tempPath}"`);
    const sqliteCmd = fs.existsSync(SQLITE_PATH) ? SQLITE_PATH : "sqlite3";
    const query = `${sqliteCmd} "${tempPath}" "SELECT value FROM cookies WHERE name = '.ROBLOSECURITY' LIMIT 1"`;
    let cookie = execSync(query).toString().trim();
    execSync(`rm "${tempPath}"`);
    if (cookie && !cookie.startsWith("_")) cookie = "_" + cookie;
    return cookie ? `.ROBLOSECURITY=${cookie}` : null;
  } catch { return null; }
}

async function getUserInfo(cookie) {
  if (!cookie) return { id: null, name: "No Cookie" };
  try {
    const res = await axios.get("https://users.roblox.com/v1/users/authenticated", {
      headers: { Cookie: cookie, "User-Agent": "Mozilla/5.0 (Android 10; Mobile)" }
    });
    return { id: res.data.id, name: res.data.name };
  } catch { return { id: null, name: "Expired" }; }
}

function isProcessRunning(packageName) {
  try { execSync(`pidof ${packageName}`, { stdio: 'ignore' }); return true; } catch { return false; }
}

function stopPackage(pkg) { try { execSync(`am force-stop ${pkg}`); } catch {} }

function launchPackage(pkg, url) {
  try {
    const cmd = `am start -n ${pkg}/com.roblox.client.ActivityProtocolLaunch -a android.intent.action.VIEW -d "${url}"`;
    execSync(cmd, { stdio: 'ignore' });
  } catch {}
}

async function getBatchPresence(accounts) {
  const validAccounts = accounts.filter(a => a.userId && a.cookie);
  if (validAccounts.length === 0) return {};
  const userIds = validAccounts.map(a => a.userId);
  try {
    const res = await axios.post("https://presence.roblox.com/v1/presence/users", 
      { userIds: userIds },
      { headers: { Cookie: validAccounts[0].cookie, "Content-Type": "application/json" } }
    );
    const presenceMap = {};
    res.data.userPresences.forEach(p => {
      let status = "Unknown";
      if (p.userPresenceType === 2) status = "In Game üéÆ";
      else if (p.userPresenceType === 1) status = "Online üü°";
      else if (p.userPresenceType === 0) status = "Offline ‚ö´";
      presenceMap[p.userId] = status;
    });
    return presenceMap;
  } catch { return {}; }
}

// === NEW: Fetch Link Codes ===
async function fetchLinkCodes() {
  console.log("üåê Fetching Private Server codes...");
  try {
    const res = await axios.get(MSRV_URL);
    // Split by newline and filter empty lines
    return res.data.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  } catch (e) {
    console.log("‚ùå Failed to fetch codes. Check internet connection.");
    return [];
  }
}

// === MAIN LOGIC ===
async function main() {
  initSystem();
  console.clear();
  console.log("üöÄ Initializing Roblox Manager...");

  // 1. Fetch Packages
  const packages = getPackages();
  if (!packages.length) { console.log("‚ùå No Roblox packages found."); process.exit(0); }

  let accounts = [];
  for (const pkg of packages) {
    process.stdout.write(`Reading ${pkg}... \r`);
    const cookie = getRobloxCookie(pkg);
    const userInfo = await getUserInfo(cookie);
    accounts.push({ pkg, cookie, userId: userInfo.id, username: userInfo.name });
  }
  console.log(`\n‚úÖ Loaded ${accounts.length} accounts.`);

  // 2. Fetch & Choose Link Code
  const codes = await fetchLinkCodes();
  if (codes.length === 0) {
    console.log("‚ö†Ô∏è No codes found in the file. Exiting.");
    process.exit(1);
  }

  console.log("\nüìú Available Link Codes:");
  codes.forEach((code, index) => {
    console.log(`[${index + 1}] ${code}`);
  });

  const selection = await ask("\nüëâ Choose Server (Number): ");
  const index = parseInt(selection) - 1;
  
  if (isNaN(index) || index < 0 || index >= codes.length) {
    console.log("‚ùå Invalid selection. Exiting.");
    process.exit(1);
  }

  const selectedCode = codes[index];
  // Construct the full URL using the fixed Place ID and selected Code
  // Assumes the file contains just the code (e.g., 157220...) OR full link.
  // We extract just the code if it's a full link to be safe, or just use it if it's raw.
  let cleanCode = selectedCode;
  if(selectedCode.includes("linkCode=")) {
     cleanCode = selectedCode.split("linkCode=")[1].split("&")[0];
  }
  
  const finalLaunchUrl = `roblox://placeID=${PLACE_ID}&linkCode=${cleanCode}`;
  console.log(`\n‚úÖ Selected Code: ${cleanCode}`);

  // 3. Initial Launch
  console.log("\nüöÄ Launching all instances...");
  for (const acc of accounts) {
    stopPackage(acc.pkg);
    launchPackage(acc.pkg, finalLaunchUrl);
    await sleep(8000);
  }

  // 4. Continuous Mode (Default)
  console.log(`\nüí§ Monitoring started (Checking every ${MIN_DELAY_SECONDS}s)...`);
  
  while (true) {
    await sleep(MIN_DELAY_SECONDS * 1000);

    const presenceMap = await getBatchPresence(accounts);
    console.clear(); 
    console.log(`üìä Status (${new Date().toLocaleTimeString()}) - Active Monitor`);
    console.log(`üîó Server: ...${cleanCode.slice(-6)}`);

    const table = new Table({ head: ['User', 'State', 'Status', 'Action'], colWidths: [12, 12, 15, 20] });

    for (const acc of accounts) {
      const isRunning = isProcessRunning(acc.pkg);
      const serverStatus = presenceMap[acc.userId] || "Unknown";
      let action = "-";

      const isStuck = serverStatus.includes("Online"); // Stuck in menu
      
      if (!isRunning || isStuck) {
        if (isRunning && isStuck) {
          stopPackage(acc.pkg);
          action = "‚ôªÔ∏è RESTART (Stuck)";
        } else {
          action = "‚ôªÔ∏è REOPEN (Closed)";
        }
        launchPackage(acc.pkg, finalLaunchUrl);
      }

      table.push([acc.username.substring(0, 10), isRunning ? "Run üü¢" : "Dead üî¥", serverStatus, action]);
    }
    console.log(table.toString());
  }
}

main();
