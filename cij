#!/system/bin/sh

# ==========================================================
# ROBLOX INJECTOR v10.0 (AUTO-SKIP + VALIDATOR)
# ==========================================================

TERMUX_SQLITE="/data/data/com.termux/files/usr/bin/sqlite3"
TMP_SQLITE="/data/local/tmp/sqlite3_exec"
TEMP_DB_DIR="/data/local/tmp/rbx_temp_cookies"
COOKIE_QUEUE="/data/local/tmp/rbx_queue.txt"

check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "‚ùå Script ini MEMBUTUHKAN akses Root!"
        exit 1
    fi
}

prepare_env() {
    # Cek Curl untuk validasi
    if ! command -v curl >/dev/null 2>&1; then
        echo "‚ùå Curl tidak ditemukan. Install dulu: pkg install curl"
        exit 1
    fi

    rm -f "$TMP_SQLITE"
    if [ -f "$TERMUX_SQLITE" ]; then
        cp "$TERMUX_SQLITE" "$TMP_SQLITE"
        chmod 755 "$TMP_SQLITE"
        SQLITE_BIN="$TMP_SQLITE"
    else
        SQLITE_BIN=$(which sqlite3)
    fi

    if [ -z "$SQLITE_BIN" ] || [ ! -x "$SQLITE_BIN" ]; then
        echo "‚ùå sqlite3 tidak ditemukan. Wajib install: pkg install sqlite"
        exit 1
    fi

    rm -rf "$TEMP_DB_DIR"
    mkdir -p "$TEMP_DB_DIR"
    chmod 777 "$TEMP_DB_DIR"
}

# --- FUNGSI 1: CEK APAKAH APK SUDAH LOGIN ---
check_existing_cookie() {
    local pkg="$1"
    local db_path="/data/data/$pkg/app_webview/Default/Cookies"
    
    if [ ! -f "$db_path" ]; then return 1; fi

    local cookie_value=$("$SQLITE_BIN" "$db_path" "SELECT value FROM cookies WHERE name='.ROBLOSECURITY' LIMIT 1;" 2>/dev/null)
    
    if [ -n "$cookie_value" ]; then
        return 0 # Ada isinya (Sudah login)
    else
        return 1 # Kosong
    fi
}

# --- FUNGSI 2: CEK VALIDITAS COOKIE VIA INTERNET ---
validate_cookie_online() {
    local cookie_val="$1"
    
    echo -n "   ‚è≥ Mengecek validitas... "
    
    # Hit API Roblox untuk cek user login
    # Timeout 10 detik agar tidak hang jika sinyal jelek
    response=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 \
        -H "Cookie: .ROBLOSECURITY=$cookie_val" \
        "https://users.roblox.com/v1/users/authenticated")

    if [ "$response" -eq 200 ]; then
        echo "‚úÖ VALID (Live)"
        return 0
    else
        echo "‚ùå MATI/INVALID ($response)"
        return 1
    fi
}

generate_db_file() {
    local index="$1"
    local raw_cookie="$2"
    local db_path="$TEMP_DB_DIR/cookie_$index.db"

    rm -f "$db_path"
    "$SQLITE_BIN" "$db_path" "CREATE TABLE cookies(creation_utc INTEGER NOT NULL, top_frame_site_key TEXT NOT NULL, host_key TEXT NOT NULL, name TEXT NOT NULL, value TEXT NOT NULL, encrypted_value BLOB DEFAULT '', path TEXT NOT NULL, expires_utc INTEGER NOT NULL, is_secure INTEGER NOT NULL, is_httponly INTEGER NOT NULL, last_access_utc INTEGER NOT NULL, has_expires INTEGER NOT NULL DEFAULT 1, is_persistent INTEGER NOT NULL DEFAULT 1, priority INTEGER NOT NULL DEFAULT 1, samesite INTEGER NOT NULL DEFAULT -1, source_scheme INTEGER NOT NULL DEFAULT 0, source_port INTEGER NOT NULL DEFAULT -1, is_same_party INTEGER NOT NULL DEFAULT 0, UNIQUE (top_frame_site_key, host_key, name, path));"
    "$SQLITE_BIN" "$db_path" "CREATE TABLE meta(key LONGVARCHAR NOT NULL UNIQUE PRIMARY KEY, value LONGVARCHAR);"
    "$SQLITE_BIN" "$db_path" "INSERT INTO meta(key, value) VALUES('version','15');"
    "$SQLITE_BIN" "$db_path" "INSERT INTO meta(key, value) VALUES('last_compatible_version','15');"
    "$SQLITE_BIN" "$db_path" "INSERT INTO cookies (creation_utc, top_frame_site_key, host_key, name, value, encrypted_value, path, expires_utc, is_secure, is_httponly, last_access_utc, has_expires, is_persistent, priority, samesite, source_scheme, source_port, is_same_party) VALUES ((strftime('%s','now')*1000000), '', '.roblox.com', '.ROBLOSECURITY', '$raw_cookie', '', '/', 253402300799000000, 1, 1, (strftime('%s','now')*1000000), 1, 1, 1, -1, 1, -1, 0);"
}

restore_db() {
    local pkg_name="$1"
    local source_db="$2"
    local target_root="/data/data/$pkg_name"
    local target_folder="$target_root/app_webview/Default"
    local target_file="$target_folder/Cookies"

    echo "   üîÑ Injecting: $pkg_name"
    am force-stop "$pkg_name" > /dev/null 2>&1

    if [ -e "$target_file" ]; then rm -f "$target_file"; fi
    if [ -d "$target_file" ]; then rm -rf "$target_file"; fi

    if [ ! -d "$target_folder" ]; then
        mkdir -p "$target_folder"
        local uid_awal=$(stat -c "%u:%g" "$target_root")
        chown -R "$uid_awal" "$target_root/app_webview"
    fi

    cp "$source_db" "$target_file"
    local app_uid=$(stat -c "%u:%g" "$target_root")
    chown -R "$app_uid" "$target_root/app_webview"
    chmod 660 "$target_file"
}

do_main_process() {
    echo "=========================================="
    echo " ROBLOX INJECTOR v10 (VALIDATOR EDITION)"
    echo "=========================================="
    prepare_env
    
    raw_pkgs=($(pm list packages | grep "com.roblox.clien" | cut -f 2 -d ":"))
    
    if [ ${#raw_pkgs[@]} -eq 0 ]; then
        echo "‚ùå Tidak ada aplikasi Roblox Clone."
        return
    fi

    echo "üîç Memeriksa status login & memfilter..."
    target_pkgs=()

    for pkg in "${raw_pkgs[@]}"; do
        if check_existing_cookie "$pkg"; then
            echo "   ‚è© SKIP: $pkg (Sudah Login)"
        else
            echo "   üéØ TARGET: $pkg (Perlu Injeksi)"
            target_pkgs+=("$pkg")
        fi
    done

    total_targets=${#target_pkgs[@]}

    if [ $total_targets -eq 0 ]; then
        echo "‚úÖ Semua aplikasi aman. Keluar."
        rm -rf "$TEMP_DB_DIR"
        exit 0
    fi

    echo "------------------------------------------"
    echo "üìù Mengisi $total_targets slot kosong."
    echo "   Ketik 'done' untuk batal/keluar."
    echo "------------------------------------------"
    
    rm -f "$COOKIE_QUEUE"
    
    # Loop untuk setiap target yang kosong
    i=0
    while [ $i -lt $total_targets ]; do
        display_num=$((i + 1))
        current_target_pkg="${target_pkgs[$i]}"
        
        # Infinite loop kecil sampai user memasukkan cookie yang VALID untuk app ini
        while true; do
            echo ""
            echo "üëâ [$display_num/$total_targets] Target: ...${current_target_pkg: -15}"
            echo -n "   Paste Cookie: "
            read -r input_cookie

            # Handle exit
            if [ "$input_cookie" = "done" ]; then 
                # Jika user keluar di tengah, kita proses yang sudah ada saja
                echo "‚ö†Ô∏è  Proses dihentikan user."
                break 2 
            fi

            # Handle kosong
            if [ -z "$input_cookie" ]; then
                echo "   ‚ùå Cookie tidak boleh kosong!"
                continue
            fi

            # --- VALIDASI ONLINE ---
            if validate_cookie_online "$input_cookie"; then
                # Jika valid, simpan ke queue dan BREAK loop kecil untuk lanjut ke app berikutnya
                echo "$input_cookie" >> "$COOKIE_QUEUE"
                i=$((i + 1))
                break 
            else
                # Jika tidak valid, ulangi prompt (jangan break)
                echo "   ‚ö†Ô∏è  Silakan ambil cookie baru dan paste ulang."
            fi
        done
    done
    
    total_cookies_input=$i

    if [ $total_cookies_input -eq 0 ]; then
        echo "‚ùå Tidak ada cookie valid yang diinput."
        rm -rf "$TEMP_DB_DIR"
        exit 0
    fi

    # Phase 1: Generate & Inject
    echo "------------------------------------------"
    echo "üöÄ Memproses & Mengirim ke Aplikasi..."
    
    idx=0
    # Kita loop ulang file queue yang isinya sudah pasti valid
    while read -r valid_cookie; do
        if [ $idx -ge ${#target_pkgs[@]} ]; then break; fi
        
        # 1. Generate DB
        generate_db_file "$((idx+1))" "$valid_cookie"
        
        # 2. Inject langsung
        target_app="${target_pkgs[$idx]}"
        source_db="$TEMP_DB_DIR/cookie_$((idx+1)).db"
        
        restore_db "$target_app" "$source_db"
        
        idx=$((idx + 1))
    done < "$COOKIE_QUEUE"

    rm -rf "$TEMP_DB_DIR"
    rm -f "$COOKIE_QUEUE"
    echo "------------------------------------------"
    echo "‚ú® SELESAI! Semua cookie yang masuk sudah dites valid."
}

check_root
do_main_process
